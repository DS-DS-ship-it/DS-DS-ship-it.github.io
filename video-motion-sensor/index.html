<!-- deploy-bump: 2026-02-08T01:28:02Z -->
<!-- deploy-bump: 2026-02-08T01:23:45Z -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Motion Tracker (Safari Memory Safe) + Auto Record + PiP Zoom</title>
  <style>
    :root { color-scheme: dark; }
    body{ margin:0; background:#0b0c10; color:#e9eef5; font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; }
    .wrap{ display:grid; grid-template-columns: 1fr 380px; gap:12px; padding:12px; }
    .stage{
      position:relative;
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      overflow:hidden;
      background:#000;
      box-shadow:0 12px 40px rgba(0,0,0,.45);
      min-height: 380px;
    }
    canvas#view{ width:100%; height:auto; display:block; background:#000; }

    .hud{
      position:absolute; left:10px; bottom:10px; right:10px;
      display:flex; gap:8px; flex-wrap:wrap; align-items:center;
      pointer-events:auto;
    }
    button{
      background: rgba(15,18,24,.75);
      border:1px solid rgba(255,255,255,.16);
      color:#e9eef5;
      padding:8px 10px;
      border-radius:10px;
      cursor:pointer;
      font-weight:600;
    }
    button:hover{ filter:brightness(1.08); }
    button:disabled{ opacity:.55; cursor:not-allowed; }
    .pill{
      position:absolute; left:10px; top:10px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(15,18,24,.65);
      backdrop-filter: blur(8px);
      font-size:12px;
      display:flex; gap:10px; align-items:center;
      z-index: 5;
    }
    .dot{ width:10px; height:10px; border-radius:50%; background:#777; }
    .dot.ok{ background:#39d353; }
    .dot.rec{ background:#ff4d4d; box-shadow:0 0 0 0 rgba(255,77,77,.55); animation:pulse 1.1s infinite; }
    .dot.warn{ background:#ffcc00; }
    @keyframes pulse { 0%{box-shadow:0 0 0 0 rgba(255,77,77,.55);} 100%{box-shadow:0 0 0 10px rgba(255,77,77,0);} }

    .panel{
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      background: rgba(15,18,24,.72);
      box-shadow:0 12px 40px rgba(0,0,0,.35);
      padding:12px;
      height: fit-content;
    }
    .row{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin:8px 0; }
    .row label{ display:flex; gap:8px; align-items:center; user-select:none; }
    input[type="range"]{ width:190px; }
    .small{ opacity:.8; font-size:12px; }
    code{ background:rgba(255,255,255,.08); padding:2px 6px; border-radius:6px; }

    /* PiP window */
    .pip{
      position:fixed;      right:12px; bottom:12px;
      border-radius:12px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.18);
      background:#000;
      box-shadow:0 12px 30px rgba(0,0,0,.55);
      display:none;
      z-index: 6;
      user-select:none;
      touch-action:none;
    
      position:fixed;
      isolation:isolate;
    }
    .pip.smallMode{ width:240px; height:150px; }
    /* large = ~ 1/4 screen-ish (click to toggle) */
    .pip.largeMode{ width:min(52vw, 760px); height:min(34vw, 460px); }
    canvas#pipView{ width:100%; height:100%; display:block; background:#000; 
      position:absolute; inset:0; z-index:1;
    }

    /* draggable header */
    .pipHeader{
      position:absolute; left:0; top:0; right:0;
      height:30px;
      display:flex; align-items:center; justify-content:space-between;
      padding:0 8px;
      background: rgba(15,18,24,.62);
      border-bottom:1px solid rgba(255,255,255,.12);
      cursor: grab;
      z-index:2;
    
      z-index:3;
    }
    .pipHeader:active{ cursor:grabbing; }
    .pipTitle{
      font-size:11px;
      opacity:.95;
      pointer-events:none;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 75%;
    }
    .pipHint{
      font-size:11px;
      opacity:.7;
      pointer-events:none;
    }

    .hint{
      margin-top:8px;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      font-size:12px;
      opacity:.9;
    }

    video#cam { position:absolute; left:-99999px; top:-99999px; width:1px; height:1px; opacity:0; }
    /* PiP header button */
    .pipBtn{
      pointer-events:auto;
      background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.18);
      color:#e9eef5;
      padding:4px 8px;
      border-radius:10px;
      font:11px/1.0 ui-monospace, Menlo, monospace;
      cursor:pointer;
    }
    .pipBtn:hover{ filter:brightness(1.15); }
    .pipBtn:disabled{ opacity:.55; cursor:not-allowed; }

  </style>
</head>
<body>
  <div class="wrap">
    <div class="stage" id="stage">
      <div class="pill">
        <span class="dot" id="dot"></span>
        <span id="status">Idle</span>
        <span class="small" id="fps">—</span>
        <span class="small" id="work">work —</span>
      </div>

      <canvas id="view"></canvas>

      <div class="pip smallMode" id="pip" title="Click canvas to enlarge / shrink">
        <div class="pipHeader" id="pipHeader">
          <div class="pipTitle" id="pipTitle">Motion Zoom</div>
          <div class="pipHint">drag • click</div>
          <button class="pipBtn" id="pipRec" type="button">Rec PiP</button>
          <button class="pipBtn" id="pipDl" type="button" disabled>DL PiP</button>

          <button class="pipBtn" id="pipToggle" type="button">Enlarge</button>
        </div>
        <canvas id="pipView"></canvas>
      </div>

      <div class="hud">
        <button id="btnStart">Enable camera</button>
        <button id="btnMask">Mask draw: OFF</button>
        <button id="btnSnap" disabled>Snapshot</button>
        <button id="btnRec" disabled>Start recording</button>
        <button id="btnDownload" disabled>Download last clip</button>
        <button id="btnClearMask" disabled>Clear mask</button>
        <button id="btnPause" disabled>Pause detection</button>
      </div>

      <video id="cam" playsinline muted autoplay></video>
    </div>

    <div class="panel">
      <div class="row">
        <label><input type="checkbox" id="chkDetect" checked> Enable detection</label>
      </div>
      <div class="row">
        <!-- ✅ not selected on boot -->
        <label><input type="checkbox" id="chkAutoRec"> Auto-record on motion</label>
      </div>
      <div class="row">
        <label><input type="checkbox" id="chkShowPip" checked> Show PiP zoom</label>
      </div>
      <div class="row">
        <label><input type="checkbox" id="chkFollow" checked> Follow (smooth) track</label>
      </div>
      <div class="row">
        <label><input type="checkbox" id="chkAutoDownshift" checked> Auto downshift (Safari-safe)</label>
      </div>

      <hr style="border:0;border-top:1px solid rgba(255,255,255,.10); margin:10px 0;">

      <div class="small" style="margin-bottom:6px; font-weight:700;">Performance / Quality</div>

      <div class="row">
        <div>Detection FPS</div>
        <div><input type="range" id="rngDetFps" min="4" max="24" step="1" value="10"><span class="small" id="valDetFps">10</span></div>
      </div>

      <div class="row">
        <div>Render scale</div>
        <div><input type="range" id="rngScale" min="0.45" max="1.00" step="0.05" value="0.70"><span class="small" id="valScale">0.70</span></div>
      </div>

      <div class="row">
        <div>Processing width</div>
        <div><input type="range" id="rngProcW" min="224" max="640" step="16" value="288"><span class="small" id="valProcW">288px</span></div>
      </div>

      <div class="row">
        <div>PiP size</div>
        <div><input type="range" id="rngPip" min="180" max="520" step="10" value="260"><span class="small" id="valPip">260px</span></div>
      </div>

      <hr style="border:0;border-top:1px solid rgba(255,255,255,.10); margin:10px 0;">

      <div class="small" style="margin-bottom:6px; font-weight:700;">Robustness Controls</div>

      <div class="row">
        <div>Background adapt</div>
        <div><input type="range" id="rngAlpha" min="0.01" max="0.25" step="0.01" value="0.06"><span class="small" id="valAlpha">0.06</span></div>
      </div>

      <div class="row">
        <div>Threshold</div>
        <div><input type="range" id="rngThr" min="5" max="60" step="1" value="22"><span class="small" id="valThr">22</span></div>
      </div>

      <div class="row">
        <div>Min blob area</div>
        <div><input type="range" id="rngMinArea" min="10" max="2500" step="10" value="70"><span class="small" id="valMinArea">70</span></div>
      </div>

      <div class="row">
        <div>Morph radius</div>
        <div><input type="range" id="rngMorph" min="0" max="2" step="1" value="1"><span class="small" id="valMorph">1</span></div>
      </div>

      <div class="row">
        <div>Hold (sec)</div>
        <div><input type="range" id="rngHold" min="0.2" max="5.0" step="0.1" value="1.5"><span class="small" id="valHold">1.5</span></div>
      </div>

      <div class="row">
        <div>Stop after quiet (sec)</div>
        <div><input type="range" id="rngQuiet" min="0.5" max="12" step="0.5" value="5.0"><span class="small" id="valQuiet">5.0</span></div>
      </div>

      <div class="row">
        <div>Max tracks</div>
        <div><input type="range" id="rngMaxTracks" min="1" max="10" step="1" value="5"><span class="small" id="valMaxTracks">5</span></div>
      </div>

      <hr style="border:0;border-top:1px solid rgba(255,255,255,.10); margin:10px 0;">

      <div class="small" style="margin-bottom:6px; font-weight:700;">Recording (stable)</div>

      <div class="row">
        <div>Rec FPS</div>
        <div><input type="range" id="rngRecFps" min="10" max="30" step="1" value="30"><span class="small" id="valRecFps">30</span></div>
      </div>

      <div class="row">
        <div>Bitrate (Mbps)</div>
        <div><input type="range" id="rngMbps" min="2" max="18" step="1" value="8"><span class="small" id="valMbps">8</span></div>
      </div>

      <div class="row">
        <div>Timeslice (ms)</div>
        <div><input type="range" id="rngSlice" min="500" max="4000" step="100" value="1500"><span class="small" id="valSlice">1500</span></div>
      </div>

      <div class="hint">
        <b>Recording stability:</b> records the <code>view</code> canvas (boxes included) with timesliced chunks, and releases the capture stream on stop to prevent tab memory growth.
      </div>
      <div class="hint">
        <b>PiP:</b> drag by the header; click the PiP canvas to toggle small ⇄ ~¼ screen.
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  // ---- DOM ----
  const stage = document.getElementById("stage");
  const video = document.getElementById("cam");

  const view = document.getElementById("view");
  const vctx = view.getContext("2d", { alpha:false, desynchronized:true });

  const pipWrap = document.getElementById("pip");
  const pipHeader = document.getElementById("pipHeader");
  const pipView = document.getElementById("pipView");
  const pctx = pipView.getContext("2d", { alpha:false, desynchronized:true });

  const pipRecBtn = document.getElementById("pipRec");
  const pipDlBtn  = document.getElementById("pipDl");
  const pipToggle = document.getElementById("pipToggle");
  const pipTitle = document.getElementById("pipTitle");

  const dot = document.getElementById("dot");
  const statusEl = document.getElementById("status");
  const fpsEl = document.getElementById("fps");
  const workEl = document.getElementById("work");

  const btnStart = document.getElementById("btnStart");
  const btnMask = document.getElementById("btnMask");
  const btnSnap = document.getElementById("btnSnap");
  const btnRec = document.getElementById("btnRec");
  const btnDownload = document.getElementById("btnDownload");
  const btnClearMask = document.getElementById("btnClearMask");
  const btnPause = document.getElementById("btnPause");

  const chkDetect = document.getElementById("chkDetect");
  const chkAutoRec = document.getElementById("chkAutoRec");     // ✅ default OFF in HTML
  const chkShowPip = document.getElementById("chkShowPip");
  const chkFollow = document.getElementById("chkFollow");
  const chkAutoDownshift = document.getElementById("chkAutoDownshift");

  const rngDetFps = document.getElementById("rngDetFps");
  const rngScale  = document.getElementById("rngScale");
  const rngProcW  = document.getElementById("rngProcW");
  const rngPip    = document.getElementById("rngPip");

  const rngAlpha = document.getElementById("rngAlpha");
  const rngThr = document.getElementById("rngThr");
  const rngMinArea = document.getElementById("rngMinArea");
  const rngMorph = document.getElementById("rngMorph");
  const rngHold = document.getElementById("rngHold");
  const rngQuiet = document.getElementById("rngQuiet");
  const rngMaxTracks = document.getElementById("rngMaxTracks");

  const rngRecFps = document.getElementById("rngRecFps");
  const rngMbps = document.getElementById("rngMbps");
  const rngSlice = document.getElementById("rngSlice");

  const valDetFps = document.getElementById("valDetFps");
  const valScale  = document.getElementById("valScale");
  const valProcW  = document.getElementById("valProcW");
  const valPip    = document.getElementById("valPip");

  const valAlpha = document.getElementById("valAlpha");
  const valThr = document.getElementById("valThr");
  const valMinArea = document.getElementById("valMinArea");
  const valMorph = document.getElementById("valMorph");
  const valHold = document.getElementById("valHold");
  const valQuiet = document.getElementById("valQuiet");
  const valMaxTracks = document.getElementById("valMaxTracks");

  const valRecFps = document.getElementById("valRecFps");
  const valMbps = document.getElementById("valMbps");
  const valSlice = document.getElementById("valSlice");

  function syncLabels(){
    valDetFps.textContent = `${rngDetFps.value}`;
    valScale.textContent  = `${Number(rngScale.value).toFixed(2)}`;
    valProcW.textContent  = `${rngProcW.value}px`;
    valPip.textContent    = `${rngPip.value}px`;

    valAlpha.textContent = `${Number(rngAlpha.value).toFixed(2)}`;
    valThr.textContent = `${rngThr.value}`;
    valMinArea.textContent = `${rngMinArea.value}`;
    valMorph.textContent = `${rngMorph.value}`;
    valHold.textContent = `${Number(rngHold.value).toFixed(1)}`;
    valQuiet.textContent = `${Number(rngQuiet.value).toFixed(1)}`;
    valMaxTracks.textContent = `${rngMaxTracks.value}`;

    valRecFps.textContent = `${rngRecFps.value}`;
    valMbps.textContent = `${rngMbps.value}`;
    valSlice.textContent = `${rngSlice.value}`;
  }
  [
    rngDetFps,rngScale,rngProcW,rngPip,
    rngAlpha,rngThr,rngMinArea,rngMorph,rngHold,rngQuiet,rngMaxTracks,
    rngRecFps,rngMbps,rngSlice
  ].forEach(el => el.addEventListener("input", syncLabels));
  syncLabels();

  // ---- Helpers ----
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const now = ()=>performance.now();

  function setStatus(text, mode){
    statusEl.textContent = text;
    dot.classList.remove("ok","rec","warn");
    dot.classList.add(mode || "ok");
  }

  // ---- Processing canvases (small) ----
  const proc = document.createElement("canvas");
  const prc = proc.getContext("2d", { willReadFrequently:true });

  const maskC = document.createElement("canvas");
  const mctx = maskC.getContext("2d");

  // ---- Reused buffers (NO per-frame allocations) ----
  let maskBits = null;       // Uint8Array(w*h)
  let maskDirty = true;

  let bgF = null;            // Float32Array(w*h*3)

  let binA = null;           // Uint8Array(w*h)
  let binB = null;           // Uint8Array(w*h) (for morph)
  let visited = null;        // Uint8Array(w*h)
  let queue = null;          // Uint32Array(w*h) BFS queue (max)
  let queueHead = 0, queueTail = 0;

  // Tracks
  let tracks = [];
  let nextId = 1;

  // Mask drawing
  let maskDraw = false;
  let painting = false;
  let lastPt = null;

  // Detection throttle + load control
  let lastWorkMs = 0;
  let heavyStrikes = 0;
  let pausedUntil = 0;

  // Bitmap caching (reduces internal copies in Safari)
  let lastBitmapAt = 0;
  let lastBitmap = null;

  // Recording (STABLE + DOWNLOADABLE)
  let recorder = null;
  let recStream = null;              // ✅ keep reference so we can stop tracks (prevents leaks/crashes)
  let recBlobs = [];
  let lastClipBlob = null;
  let recording = false;

  // ---- PiP recording ----
  let pipRecorder = null;
  let pipStream = null;
  let pipBlobs = [];
  let lastPipBlob = null;
  let pipRecording = false;
  let pipRecStartAt = 0;

  // Auto recording gate
  let lastMotionAt = 0;
  let motionHoldUntil = 0;

  // PiP state
  let pipLarge = false;
  let pipDrag = { on:false, dx:0, dy:0 };

  // Ensure drag always releases even if pointerup occurs outside header
  window.addEventListener("pointerup", function(){ pipDrag.on = false; }, {passive:true});
  window.addEventListener("pointercancel", function(){ pipDrag.on = false; }, {passive:true});
  // store pip position (so it stays where you drag it)
  let pipPos = { left:null, top:null, right:12, bottom:12 };

  function allocBuffers(){
    const w = proc.width, h = proc.height;
    maskBits = new Uint8Array(w*h);
    binA = new Uint8Array(w*h);
    binB = new Uint8Array(w*h);
    visited = new Uint8Array(w*h);
    queue = new Uint32Array(w*h);
    bgF = null;
    tracks = [];
    maskDirty = true;
  }

  function resizeAll(){
    const vw0 = video.videoWidth || 1280;
    const vh0 = video.videoHeight || 720;

    const scale = Number(rngScale.value);
    const vw = Math.max(320, Math.round(vw0 * scale));
    const vh = Math.max(240, Math.round(vh0 * scale));

    view.width = vw; view.height = vh;

    // keep pip internal reasonable (avoid GPU bloat)
    pipView.width = 640;
    pipView.height = 400;

    const pw = Number(rngProcW.value);
    const ph = Math.max(160, Math.round(pw * (vh0 / vw0)));

    proc.width = pw; proc.height = ph;
    maskC.width = pw; maskC.height = ph;
    mctx.clearRect(0,0,pw,ph);

    allocBuffers();
    workEl.textContent = `proc ${pw}×${ph}`;
  }

  function viewToProc(x, y){
    const pw = proc.width, ph = proc.height;
    const vw = view.width, vh = view.height;
    return { x: x * (pw / vw), y: y * (ph / vh) };
  }

  function rebuildMaskBits(){
    const w = proc.width, h = proc.height;
    const img = mctx.getImageData(0,0,w,h).data;
    for (let i=0, p=0; i<img.length; i+=4, p++){
      maskBits[p] = img[i] > 10 ? 1 : 0;
    }
    maskDirty = false;
  }

  function drawMaskBrush(px, py, erase){
    const r = 18;
    mctx.save();
    mctx.globalCompositeOperation = erase ? "destination-out" : "source-over";
    mctx.fillStyle = "rgba(255,255,255,0.92)";
    mctx.beginPath();
    mctx.arc(px, py, r, 0, Math.PI*2);
    mctx.fill();
    mctx.restore();
    maskDirty = true;
  }

  function bgInitOrUpdate(d, alpha){
    const w = proc.width, h = proc.height;
    if (!bgF){
      bgF = new Float32Array(w*h*3);
      for (let i=0, p=0; i<d.length; i+=4, p+=3){
        bgF[p]   = d[i];
        bgF[p+1] = d[i+1];
        bgF[p+2] = d[i+2];
      }
      return;
    }
    const a = alpha;
    for (let i=0, p=0; i<d.length; i+=4, p+=3){
      bgF[p]   += a * (d[i]   - bgF[p]);
      bgF[p+1] += a * (d[i+1] - bgF[p+1]);
      bgF[p+2] += a * (d[i+2] - bgF[p+2]);
    }
  }

  function computeBinary(d, thr){
    if (maskDirty) rebuildMaskBits();
    const t = thr;
    for (let i=0, p=0, b=0; i<d.length; i+=4, p++, b+=3){
      if (maskBits[p]) { binA[p] = 0; continue; }
      const dr = d[i]   - bgF[b];
      const dg = d[i+1] - bgF[b+1];
      const db = d[i+2] - bgF[b+2];
      const adr = dr<0? -dr: dr;
      const adg = dg<0? -dg: dg;
      const adb = db<0? -db: db;
      binA[p] = ((adr+adg+adb)/3 >= t) ? 1 : 0;
    }
  }

  function morphClose(radius){
    if (radius <= 0) return;
    const w = proc.width, h = proc.height;

    // Dilate binA -> binB
    for (let y=0;y<h;y++){
      const yw = y*w;
      for (let x=0;x<w;x++){
        let on = 0;
        for (let yy=y-radius; yy<=y+radius && !on; yy++){
          if (yy<0||yy>=h) continue;
          const yyw = yy*w;
          for (let xx=x-radius; xx<=x+radius; xx++){
            if (xx<0||xx>=w) continue;
            if (binA[yyw+xx]) { on=1; break; }
          }
        }
        binB[yw+x] = on;
      }
    }

    // Erode binB -> binA
    for (let y=0;y<h;y++){
      const yw = y*w;
      for (let x=0;x<w;x++){
        let on = 1;
        for (let yy=y-radius; yy<=y+radius && on; yy++){
          if (yy<0||yy>=h) { on=0; break; }
          const yyw = yy*w;
          for (let xx=x-radius; xx<=x+radius; xx++){
            if (xx<0||xx>=w) { on=0; break; }
            if (!binB[yyw+xx]) { on=0; break; }
          }
        }
        binA[yw+x] = on;
      }
    }
  }

  function findBlobs(minArea, maxBlobs){
    const w = proc.width, h = proc.height;
    visited.fill(0);
    const blobs = [];

    for (let y=0; y<h; y++){
      const yw = y*w;
      for (let x=0; x<w; x++){
        const p0 = yw + x;
        if (visited[p0] || !binA[p0]) continue;

        queueHead = 0; queueTail = 0;
        queue[queueTail++] = p0;
        visited[p0] = 1;

        let minX=x, minY=y, maxX=x, maxY=y, area=0;

        while (queueHead < queueTail){
          const cur = queue[queueHead++];
          const cx = cur % w;
          const cy = (cur / w) | 0;

          area++;
          if (cx<minX) minX=cx; if (cy<minY) minY=cy;
          if (cx>maxX) maxX=cx; if (cy>maxY) maxY=cy;

          for (let yy=cy-1; yy<=cy+1; yy++){
            if (yy<0||yy>=h) continue;
            const yyw2 = yy*w;
            for (let xx=cx-1; xx<=cx+1; xx++){
              if (xx<0||xx>=w) continue;
              const pp = yyw2 + xx;
              if (visited[pp] || !binA[pp]) continue;
              visited[pp] = 1;
              queue[queueTail++] = pp;
            }
          }
        }

        if (area >= minArea){
          blobs.push({x:minX,y:minY,w:(maxX-minX+1),h:(maxY-minY+1),area});
          if (blobs.length >= maxBlobs) return blobs;
        }
      }
    }
    return blobs;
  }

  function iou(a,b){
    const ax2=a.x+a.w, ay2=a.y+a.h;
    const bx2=b.x+b.w, by2=b.y+b.h;
    const ix1=Math.max(a.x,b.x), iy1=Math.max(a.y,b.y);
    const ix2=Math.min(ax2,bx2), iy2=Math.min(ay2,by2);
    const iw=Math.max(0, ix2-ix1), ih=Math.max(0, iy2-iy1);
    const inter=iw*ih;
    const ua=a.w*a.h + b.w*b.h - inter;
    return ua>0 ? inter/ua : 0;
  }

  function updateTracks(blobs, t, maxTracks){
    const used = new Uint8Array(blobs.length);
    for (const tr of tracks){
      let best=-1, bestJ=-1;
      for (let j=0;j<blobs.length;j++){
        if (used[j]) continue;
        const s = iou(tr, blobs[j]);
        if (s > best){ best=s; bestJ=j; }
      }
      if (bestJ >= 0 && best >= 0.12){
        const b = blobs[bestJ];
        used[bestJ] = 1;
        tr.x=b.x; tr.y=b.y; tr.w=b.w; tr.h=b.h;
        tr.area=b.area; tr.lastSeen=t;
        tr.score = tr.score*0.85 + b.area*0.15;
      }
    }

    for (let j=0;j<blobs.length && tracks.length<maxTracks;j++){
      if (used[j]) continue;
      const b = blobs[j];
      tracks.push({id: nextId++, x:b.x,y:b.y,w:b.w,h:b.h, area:b.area, score:b.area, lastSeen:t});
    }

    tracks = tracks.filter(tr => (t - tr.lastSeen) < 2000);
  }

  function strongestTrack(){
    if (!tracks.length) return null;
    let best = tracks[0];
    for (const t of tracks) if (t.score > best.score) best = t;
    return best;
  }

  // ---------- Recording (UPGRADED: stable + downloadable + no leak) ----------
  function pickMime(){
    const cands = [
      "video/webm;codecs=vp9,opus",
      "video/webm;codecs=vp8,opus",
      "video/webm"
    ];
    for (const m of cands){
      try{ if (window.MediaRecorder && MediaRecorder.isTypeSupported(m)) return m; }catch{}
    }
    return "";
  }

  async function addMicTo(stream){
    try{
      const mic = await navigator.mediaDevices.getUserMedia({ audio:true });
      mic.getAudioTracks().forEach(t => stream.addTrack(t));
      // Keep a handle so we can stop mic tracks too:
      stream.__mic = mic;
    }catch{}
    return stream;
  }

  async function startRecording(){
    if (recording) return;
    if (!video.videoWidth) return;

    // always stop any previous clip URL
    lastClipBlob = null;
    btnDownload.disabled = true;
    recBlobs = [];

    const fps = Number(rngRecFps.value);
    const mbps = Number(rngMbps.value);
    const slice = Number(rngSlice.value);

    // IMPORTANT: record the *view canvas* (includes overlays)
    recStream = view.captureStream(fps);
    await addMicTo(recStream);

    const mime = pickMime();
    const opts = {
      videoBitsPerSecond: mbps * 1_000_000
    };
    if (mime) opts.mimeType = mime;

    try{
      recorder = new MediaRecorder(recStream, opts);
    }catch(e){
      console.error(e);
      setStatus("Recorder init failed", "warn");
      // cleanup stream
      stopRecStream();
      return;
    }

    recorder.ondataavailable = (e)=>{ if (e.data && e.data.size) recBlobs.push(e.data); };
    recorder.onerror = (e)=>{
      console.error("Recorder error", e);
      setStatus("Recorder error", "warn");
      stopRecording(true);
    };
    recorder.onstop = ()=>{
      // assemble one blob and enable download
      try{
        lastClipBlob = new Blob(recBlobs, { type: (recBlobs[0] && recBlobs[0].type) || (mime || "video/webm") });
        btnDownload.disabled = !lastClipBlob || lastClipBlob.size === 0;
      }catch{
        btnDownload.disabled = true;
      }
      stopRecStream(); // ✅ critical: stops capture + mic tracks so Safari doesn’t grow memory
    };

    recorder.start(slice); // timeslice => memory stable
    recording = true;
    pipWrap.__mainRecStartAt = performance.now();
    btnRec.textContent = "Stop recording";
    setStatus("Recording…", "rec");
  }

  function stopRecStream(){
    try{
      if (recStream){
        if (recStream.getTracks) recStream.getTracks().forEach(t=>t.stop());
        if (recStream.__mic && recStream.__mic.getTracks) recStream.__mic.getTracks().forEach(t=>t.stop());
      }
    }catch{}
    recStream = null;
  }

  function stopRecording(silent=false){
    if (!recording) return;
    recording = false;
    btnRec.textContent = "Start recording";
    if (!silent) setStatus("Stopping…", "ok");
    try{ recorder && recorder.state !== "inactive" && recorder.stop(); }catch{}

    // stop PiP recorder too
    try { stopPipRecording(true); } catch {}
    if (pipSegTimer) { clearInterval(pipSegTimer); pipSegTimer = null; }

    recorder = null;
  }


  function downloadBlob(blob, name){
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 2500);
  }


  function stopPipStream(){
    try{
      if (pipStream && pipStream.getTracks) pipStream.getTracks().forEach(t=>t.stop());
    }catch{}
    pipStream = null;
  }

  function startPipRecording(){
    if (pipRecording) return;
    lastPipBlob = null;
    pipBlobs = [];
    pipRecStartAt = performance.now();
    try{
      pipStream = pipView.captureStream(Number(rngRecFps.value));
      pipRecorder = new MediaRecorder(pipStream, { videoBitsPerSecond: Number(rngMbps.value) * 1_000_000 });
    }catch(e){
      console.error(e);
      stopPipStream();
      return;
    }
    pipRecorder.ondataavailable = (e)=>{ if (e.data && e.data.size) pipBlobs.push(e.data); };
    pipRecorder.onstop = ()=>{
      try{
        lastPipBlob = new Blob(pipBlobs, { type: (pipBlobs[0] && pipBlobs[0].type) || "video/webm" });
      }catch{}
      stopPipStream();
      try{ syncPipButtons(); }catch{}
    };
    pipRecorder.start(Number(rngSlice.value));
    pipRecording = true;
  }

  function stopPipRecording(silent=false){
    if (!pipRecording) return;
    pipRecording = false;
    try{ if (pipRecorder && pipRecorder.state !== "inactive") pipRecorder.stop(); }catch{}
    pipRecorder = null;
    if (!silent) { try{ syncPipButtons(); }catch{} }
  }



  function syncPipButtons(){
    if (pipRecBtn) pipRecBtn.textContent = pipRecording ? "Stop PiP" : "Rec PiP";
    if (pipDlBtn)  pipDlBtn.disabled = !(lastPipBlob && lastPipBlob.size);
  }

  if (pipRecBtn){
    pipRecBtn.addEventListener("click", (e)=>{
      e.preventDefault(); e.stopPropagation();
      if (!pipRecording) startPipRecording();
      else stopPipRecording();
      syncPipButtons();
    });
  }

  if (pipDlBtn){
    pipDlBtn.addEventListener("click", (e)=>{
      e.preventDefault(); e.stopPropagation();
      if (lastPipBlob && lastPipBlob.size){
        const ts = new Date().toISOString().replace(/[:.]/g,"-");
        downloadBlob(lastPipBlob, `motion-zoom-${ts}.webm`);
      }
    });
  }

  if (pipToggle){
    pipToggle.addEventListener("click", (e)=>{
      e.preventDefault(); e.stopPropagation();
      pipLarge = !pipLarge;
      pipWrap.classList.toggle("largeMode", pipLarge);
      pipWrap.classList.toggle("smallMode", !pipLarge);
      pipToggle.textContent = pipLarge ? "Restore" : "Enlarge";
    });
  }

  try{ syncPipButtons(); }catch{}
  function downloadLast(){
    if (!lastClipBlob) return;
    const url = URL.createObjectURL(lastClipBlob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `motion-${new Date().toISOString().replace(/[:.]/g,"-")}.webm`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 2000);
  }

  // ---- Memory / load circuit breaker ----
  function downshiftIfNeeded(){
    if (!chkAutoDownshift.checked) return;

    if (lastWorkMs > 20) heavyStrikes++; else heavyStrikes = Math.max(0, heavyStrikes-1);

    if (heavyStrikes >= 6){
      heavyStrikes = 0;

      const pw = Number(rngProcW.value);
      const fps = Number(rngDetFps.value);

      if (pw > 224){
        rngProcW.value = String(Math.max(224, pw - 32));
        syncLabels();
        resizeAll();
        setStatus("Auto downshift: lower processing", "warn");
        pausedUntil = now() + 1500;
      } else if (fps > 6){
        rngDetFps.value = String(Math.max(6, fps - 1));
        syncLabels();
        setStatus("Auto downshift: lower FPS", "warn");
        pausedUntil = now() + 1500;
      } else {
        setStatus("Cooling down (Safari)", "warn");
        pausedUntil = now() + 3500;
      }
    }
  }

  // ---- Main loop ----
  let lastFrameT = 0;
  let lastDetectT = 0;

  async function getBitmap(){
    const t = now();
    if (lastBitmap && (t - lastBitmapAt) < 66) return lastBitmap;
    if (lastBitmap) { try { lastBitmap.close(); } catch {} lastBitmap = null; }
    try{
      lastBitmap = await createImageBitmap(video);
      lastBitmapAt = t;
      return lastBitmap;
    }catch{
      return null;
    }
  }

  function drawOverlays(){
    const pw = proc.width, ph = proc.height;
    const scaleX = view.width / pw;
    const scaleY = view.height / ph;

    vctx.lineWidth = 3;
    vctx.font = "14px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
    vctx.textBaseline = "top";

    for (const tr of tracks){
      const x = tr.x * scaleX;
      const y = tr.y * scaleY;
      const w = tr.w * scaleX;
      const h = tr.h * scaleY;

      vctx.strokeStyle = "rgba(57,211,83,.95)";
      vctx.strokeRect(x, y, w, h);

      vctx.fillStyle = "rgba(0,0,0,.55)";
      vctx.fillRect(x, y-18, Math.max(120, w*0.6), 18);

      vctx.fillStyle = "rgba(255,255,255,.92)";
      vctx.fillText(`ID ${tr.id}  area ${Math.round(tr.area)}`, x+6, y-16);
    }

    if (maskDraw){
      vctx.save();
      vctx.globalAlpha = 0.18;
      vctx.imageSmoothingEnabled = false;
      vctx.drawImage(maskC, 0,0,proc.width,proc.height, 0,0,view.width,view.height);
      vctx.restore();
    }
  }

  function ensurePipPos(){
    // Apply persisted style if user dragged
    if (pipPos.left !== null){
      pipWrap.style.left = pipPos.left + "px";
      pipWrap.style.top = pipPos.top + "px";
      pipWrap.style.right = "auto";
      pipWrap.style.bottom = "auto";
    } else {
      pipWrap.style.left = "auto";
      pipWrap.style.top = "auto";
      pipWrap.style.right = pipPos.right + "px";
      pipWrap.style.bottom = pipPos.bottom + "px";
    }
  }

  function drawPip(){
    const st = strongestTrack();
    const show = chkShowPip.checked && !!st;
    pipWrap.style.display = show ? "block" : "none";
    if (!show) return;

    ensurePipPos();

    if (!pipLarge){
      const px = Number(rngPip.value);
      pipWrap.style.width = `${px}px`;
      pipWrap.style.height = `${Math.round(px * 0.62)}px`;
    } else {
      pipWrap.style.width = "";
      pipWrap.style.height = "";
    }

    // Leave room for header
    const headerH = 30;
    const dstW = pipView.width;
    const dstH = pipView.height;

    // Crop around track on main view
    const scaleX = view.width / proc.width;
    const scaleY = view.height / proc.height;

    const pad = 1.9;
    const cx = (st.x + st.w/2) * scaleX;
    const cy = (st.y + st.h/2) * scaleY;
    const ww = (st.w * scaleX) * pad;
    const hh = (st.h * scaleY) * pad;

    let sx = clamp(cx - ww/2, 0, view.width-1);
    let sy = clamp(cy - hh/2, 0, view.height-1);
    let sw = clamp(ww, 20, view.width - sx);
    let sh = clamp(hh, 20, view.height - sy);

    if (chkFollow.checked){
      const prev = pipWrap._crop || {sx,sy,sw,sh};
      const k = 0.18;
      sx = prev.sx + (sx - prev.sx)*k;
      sy = prev.sy + (sy - prev.sy)*k;
      sw = prev.sw + (sw - prev.sw)*k;
      sh = prev.sh + (sh - prev.sh)*k;
      pipWrap._crop = {sx,sy,sw,sh};
    } else {
      pipWrap._crop = {sx,sy,sw,sh};
    }

    // draw crop
    pctx.drawImage(view, sx, sy, sw, sh, 0, 0, dstW, dstH);

    // border
    pctx.strokeStyle = "rgba(57,211,83,.95)";
    pctx.lineWidth = 3;
    pctx.strokeRect(2,2,dstW-4,dstH-4);

    pipTitle.textContent = `Motion Zoom (ID ${st.id}) • click to ${pipLarge ? "shrink" : "enlarge"}`;
  }

  async function render(){
    requestAnimationFrame(render);

    if (!video.videoWidth || video.readyState < 2){
      vctx.fillStyle = "#000";
      vctx.fillRect(0,0,view.width||1280, view.height||720);
      vctx.fillStyle = "rgba(255,255,255,.75)";
      vctx.font = "16px system-ui";
      vctx.fillText("Waiting for camera…", 20, 40);
      return;
    }

    const t = now();
    const dt = t - lastFrameT;
    lastFrameT = t;
    if (dt > 0) fpsEl.textContent = `${Math.round(1000/dt)} fps`;

    // Draw main view always
    vctx.drawImage(video, 0, 0, view.width, view.height);

    // cool down if needed
    if (t < pausedUntil){
      drawOverlays();
      drawPip();
      return;
    }

    // Detection throttle
    const targetFps = Number(rngDetFps.value);
    const minStep = 1000 / targetFps;
    const doDetect = chkDetect.checked && (t - lastDetectT >= minStep);

    if (!doDetect){
      drawOverlays();
      drawPip();
      return;
    }
    lastDetectT = t;

    const t0 = now();

    // Draw into proc
    const bmp = await getBitmap();
    if (bmp){
      prc.drawImage(bmp, 0, 0, proc.width, proc.height);
    } else {
      prc.drawImage(video, 0, 0, proc.width, proc.height);
    }

    const frame = prc.getImageData(0,0,proc.width,proc.height);
    const d = frame.data;

    bgInitOrUpdate(d, Number(rngAlpha.value));
    if (!bgF){
      lastWorkMs = now() - t0;
      workEl.textContent = `work ${lastWorkMs.toFixed(1)}ms`;
      return;
    }

    computeBinary(d, Number(rngThr.value));
    morphClose(Number(rngMorph.value));

    const maxTracks = Number(rngMaxTracks.value);
    const blobs = findBlobs(Number(rngMinArea.value), maxTracks*3);
    updateTracks(blobs, t, maxTracks);

    // Auto record gate (only if user enables checkbox)
    const holdSec = Number(rngHold.value);
    const quietSec = Number(rngQuiet.value);

    const motion = tracks.length > 0;
    if (motion){
      lastMotionAt = t;
      motionHoldUntil = Math.max(motionHoldUntil, t + holdSec*1000);
    }
    const stillHolding = t < motionHoldUntil;
    const quietLongEnough = (t - lastMotionAt) > quietSec*1000;

    if (chkAutoRec.checked){
      if ((motion || stillHolding) && !recording) startRecording();
      if (recording && quietLongEnough) stopRecording();
    }

    drawOverlays();
    drawPip();

    lastWorkMs = now() - t0;
    workEl.textContent = `work ${lastWorkMs.toFixed(1)}ms • proc ${proc.width}px • det ${targetFps}fps`;
    downshiftIfNeeded();

    if (!recording) setStatus(chkDetect.checked ? "Armed" : "Detection OFF", "ok");
  }

  // ---- UI ----
  btnStart.addEventListener("click", async () => {
    try{
      setStatus("Requesting camera…", "ok");
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { width:{ ideal:1920 }, height:{ ideal:1080 }, frameRate:{ ideal:30 } },
        audio: false
      });
      video.srcObject = stream;
      await video.play();
      resizeAll();
      setStatus("Armed", "ok");
      btnStart.textContent = "Camera enabled";
      btnStart.disabled = true;

      // enable controls
      btnSnap.disabled = false;
      btnRec.disabled = false;
      btnClearMask.disabled = false;
      btnPause.disabled = false;

    }catch(e){
      console.error(e);
      setStatus("Camera blocked / unavailable", "warn");
      alert("Camera access failed. Check browser permissions and reload.");
    }
  });

  btnDownload.addEventListener("click", downloadLast);

  btnSnap.addEventListener("click", () => {
    const url = view.toDataURL("image/png");
    const a = document.createElement("a");
    a.href = url;
    a.download = `snapshot-${new Date().toISOString().replace(/[:.]/g,"-")}.png`;
    document.body.appendChild(a);
    a.click();
    a.remove();
  });

  btnRec.addEventListener("click", () => {
    if (!recording) startRecording();
    else stopRecording();
  });

  btnMask.addEventListener("click", () => {
    maskDraw = !maskDraw;
    btnMask.textContent = maskDraw ? "Mask draw: ON" : "Mask draw: OFF";
  });

  btnClearMask.addEventListener("click", () => {
    mctx.clearRect(0,0,maskC.width,maskC.height);
    maskDirty = true;
  });

  btnPause.addEventListener("click", () => {
    if (chkDetect.checked){
      chkDetect.checked = false;
      setStatus("Detection paused", "warn");
      btnPause.textContent = "Resume detection";
    } else {
      chkDetect.checked = true;
      setStatus("Armed", "ok");
      btnPause.textContent = "Pause detection";
      pausedUntil = now() + 250;
    }
  });

  btnDownload.disabled = true;

  rngScale.addEventListener("change", resizeAll);
  rngProcW.addEventListener("change", resizeAll);

  // PiP click to toggle size (same behavior), but only on canvas area, not header
  pipView.addEventListener("click", (e) => {
    pipLarge = !pipLarge;
    pipWrap.classList.toggle("largeMode", pipLarge);
    pipWrap.classList.toggle("smallMode", !pipLarge);
  });

  // ---- PiP DRAG (by header) ----
  function stageRect(){ return { left:0, top:0, width: window.innerWidth, height: window.innerHeight }; }
  function pipRect(){ return pipWrap.getBoundingClientRect(); }

  pipWrap.addEventListener("pointerdown", (e) => {
    // drag ONLY on primary button; ignore header buttons
    if (typeof e.button === "number" && e.button !== 0) return;
    if (e.target && e.target.closest && e.target.closest("button")) return;
    pipDrag.on = true;
    pipWrap.setPointerCapture(e.pointerId);
    const pr = pipRect();
    pipDrag.dx = e.clientX - pr.left;
    pipDrag.dy = e.clientY - pr.top;
  });

  pipWrap.addEventListener("pointermove", (e) => {
    if (!pipDrag.on) return;
    e.preventDefault();

    // sr no longer needed for fixed-position dragging
    const pr = pipRect();

    let left = e.clientX - pipDrag.dx;
    let top  = e.clientY - pipDrag.dy;

    // clamp inside viewport
    left = clamp(left, 6, window.innerWidth - pr.width - 6);
    top  = clamp(top, 6, window.innerHeight - pr.height - 6);

    pipPos.left = left;
    pipPos.top = top;
    pipPos.right = null;
    pipPos.bottom = null;

    ensurePipPos();
  });

  pipWrap.addEventListener("pointerup", (e) => {

    pipDrag.on = false;
  });

  // Mask painting
  view.addEventListener("mousedown", (e) => {
    if (!maskDraw) return;
    painting = true;
    lastPt = null;
    paintAt(e);
  });
  window.addEventListener("mouseup", () => { painting = false; lastPt = null; });
  view.addEventListener("mousemove", (e) => {
    if (!maskDraw || !painting) return;
    paintAt(e);
  });

  function paintAt(e){
    const rect = view.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (view.width / rect.width);
    const y = (e.clientY - rect.top) * (view.height / rect.height);
    const p = viewToProc(x,y);
    const erase = e.shiftKey;

    if (!lastPt){
      drawMaskBrush(p.x, p.y, erase);
      lastPt = p;
      return;
    }
    const dx = p.x - lastPt.x, dy = p.y - lastPt.y;
    const steps = Math.max(1, Math.ceil(Math.hypot(dx,dy)/7));
    for (let i=1;i<=steps;i++){
      const px = lastPt.x + dx*(i/steps);
      const py = lastPt.y + dy*(i/steps);
      drawMaskBrush(px, py, erase);
    }
    lastPt = p;
  }

  video.addEventListener("loadedmetadata", resizeAll);

  // Cleanup (avoid Safari keeping GPU resources forever)
  window.addEventListener("pagehide", () => {
    try { if (lastBitmap) lastBitmap.close(); } catch {}
    try { stopRecording(true); } catch {}
    try {
      const s = video.srcObject;
      if (s && s.getTracks) s.getTracks().forEach(t=>t.stop());
    } catch {}
  });

  // Default boot state
  chkAutoRec.checked = false;     // ✅ ensure off even if browser restores form state
  setStatus("Idle", "ok");
  render();
  // toast: click-through + dismiss
  const toast = document.getElementById("toast");
  const toastClose = document.getElementById("toastClose");
  if (toast) {
    toast.style.pointerEvents = "none";
  }
  if (toastClose) {
    toastClose.style.pointerEvents = "auto";
    toastClose.addEventListener("click", (e) => {
      e.preventDefault(); e.stopPropagation();
      const t = document.getElementById("toast");
      if (t) t.style.display = "none";
    });
  }
  setTimeout(() => { const t=document.getElementById("toast"); if (t) t.style.display="none"; }, 6000);

})();
</script>
</body>
</html>
